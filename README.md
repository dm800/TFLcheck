# TFLcheck
Программа для перебора всех строк, в надежде получить правила для эквивалентной системы переписываний.

### Общий смысл
Берём все строки длины `LENGTH` из алфавита `letters` (то есть перебираются ВООБЩЕ все строки этой длины и из этих букв) и,
далее, для каждой строки применяем правила из `rules.txt`. На каждом этапе применяется только одно правило, однако, если возможно применение нескольких,
они создают дерево возможных трансформаций. Как только redex'ов не осталось, полученная строка считается н.ф. и возвращается вверх.
В итоге из одного слова мы получаем от 1 до N н.ф. (одинаковые при этом удаляются). Если она одна - всё корректно, если нет - применяется алгоритм Кнута-Бендикса
для всех полученных н.ф.

Фундированный порядок - LLO (Армейский) ((Лексикографический)) (((гений))) ((((плейбой...))))

Если хотите улучшить программу - делайте, я в вас верю, вы молодцы, вы справитесь

### Тут настолько много багов, что даже представить трудно, несколько известных мне:

- Длину перебираемых строк можно поменять только в исходнике
- Автоматическое добавление правил добавляет их все и сразу, поэтому много лишних (лучше добавлять по одному)
- Всё ещё возможен сценарий нехватки памяти - проблема сама куда-то пропала, и я не знаю куда.
- Медленно. Очень медленно. Очень-очень медленно. (хорошо бы ввести параллельность, но мне в падлу)

### Общие рекомендации

- Не используйте программу.
- `#define LENGTH N` - длина строки. Пока менять вручную в исходнике, потом добавлю также через файл какой-нибудь.
- При перемещении файла .exe нужно таскать за ним папку data. Если её не будет - ошибки не появится, но также не подгрузятся правила -> программа скажет, что правил вообще не нужно и всё уже в н.ф.
- Наберитесь терпения и, лучше, всё равно периодически проверяйте ветки. Для этого при нахождении разных н.ф. программа выводит цепочку получения. НЕ ПОЛЕНИТЕСЬ ПРОВЕРЯТЬ ХОТЯ БЫ ИНОГДА.
- Если вы нашли ошибку, пожалуйста, сообщите мне (я не знаю, как её исправить, но буду рад узнать о ней). ((ЭТОТ ПУНКТ МНЕ ПРЕДЛОЖИЛ КОПИЛОТ И ОН СЛИШКОМ ХОРОШ, ЧТОБЫ ЕГО НЕ ВСТАВИТЬ))
- Молиться никогда не вредно.
- Программа не умеет в минимизацию. Учитывайте то, что результат будет вообще не минимальным.

### Про формат ввода

- В файле rules.txt правила записываются в формате: `исходная_строка -> конечная_строка`, например, `ab -> a`, `ba -> a`, `aa -> ` (если правило трансформирует в пустую строку, писать эпсилон не надо, но поставить пробел после стрелочки стоит)
- На данном этапе `letters` и `LENGTH` менять только в исходнике
- При вопросе о добавлении правил, можно ввести `y`, `yes`, `Yes`, `Y`. Остальное будет расценено как нет.

### Special thanks to:
- Орфографический фиксер от моей IDE
- Чатгпт за напоминание мне про то, как вообще в c++ делать всякие вещи, типа поиска по массиву
  (потому что систему итераторов придумал Сатана лично)
- Копилот сделал меньше всех работы, но почему-то очень хочет себя сюда вписать