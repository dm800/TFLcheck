# TFLcheck
Программа для перебора всех строк, в надежде получить правила для эквивалентной системы переписываний.

### Общий смысл
Берём все строки длины `LENGTH` из алфавита `letters` (то есть перебираются ВООБЩЕ все строки этой длины и из этих букв) и,
далее, для каждой строки применяем правила из `rules.txt`. На каждом этапе применяется только одно правило, однако, если возможно применение нескольких,
они создают дерево возможных трансформаций. Как только redex'ов не осталось, полученная строка считается н.ф. и возвращается вверх.
В итоге из одного слова мы получаем от 1 до N н.ф. (одинаковые при этом удаляются). Если она одна - всё корректно, если нет - применяется алгоритм Кнута-Бендикса
для всех полученных н.ф.

Также есть очень простенький минимайзер - убирает уж совсем избыточные правила 
(это видно в SRS, которую я привожу как пример. Правило `abca -> aaaa` полностью покрывается правилом `abc -> aaa`, поэтому при первой же итерации программа его уберёт)

Фундированный порядок - LLO (Армейский) ((Лексикографический))

Если хотите улучшить программу - делайте, я в вас верю, вы молодцы, вы справитесь

### Тут настолько много багов, что даже представить трудно, несколько известных мне:

- Минимизации полученных правил нет (почти). Я не знаю как это делать, поэтому такого не реализовано. Следствие - много правил, которые избыточны.
- Всё ещё возможен сценарий нехватки памяти - проблема сама куда-то пропала, и я не знаю куда.
- Медленно. Очень медленно. Очень-очень медленно. (хорошо бы ввести параллельность, но мне в падлу)
- Я на 99% уверен, что программа не работает, если есть переписывание из пустой строки. Учитывайте это и проверяйте результаты, если всё же решитесь использовать.

### Общие рекомендации

- Не используйте программу.
- При перемещении файла .exe нужно таскать за ним папку data. Если её не будет - ошибки не появится, но также не подгрузятся правила -> программа скажет, что правил вообще не нужно и всё уже в н.ф.
- Наберитесь терпения и, лучше, всё равно периодически проверяйте ветки. Для этого при нахождении разных н.ф. программа выводит цепочку получения.
- Молиться никогда не вредно.
- Программа не умеет в минимизацию. Учитывайте то, что результат будет вообще не минимальным.

### Про формат ввода

- В файле rules.txt правила записываются в формате: `исходная_строка -> конечная_строка`, например, `ab -> a`, `ba -> a`, `aa -> .` (если правило трансформирует в пустую строку, писать эпсилон не надо, но нужно поставить точку)
- При вопросе о добавлении правил, можно ввести `slow`, `fast`, `skip`, о них чуть дальше (только не автоматический режим)
- Первая строка в `alphabet.txt` отвечает за длину строки и режим работы. Чем длиннее - тем дольше и нестабильнее программа. Воо


### О режиме работы

При выполнении первой итерации, программа покажет, какие правила она считает нужными для добавления. Далее есть 3 варианта

`skip` - пропуск, то есть изначальная система правил никак изменена не будет и вы, например, можете сами выбрать какое правило внести и добавить его вручную.


`fast` - все правила будут добавлены каскадом. То есть перепроверок проводиться не будет и, есть вероятность, что при таком выборе появится много избыточных правил.


`slow` - добавляет правила по одному и перепроверяет систему. Так есть возможность избежать добавления части лишних правил. Рекомендованный способ запуска.


Также, в первой строке `alphabet.txt` можно указать режим `auto N`. Если указать этот режим, программа сама прогонит все длины от 1 до N, добавляя правила в систему методом slow. 
Используя этот подход готовьтесь ждать, долго и мучительно. Если в первой строке указать просто число N, то переберутся только строки начальной длины N и новые правила будут исходить только из них.


Пример файлов `rules.txt` и `alphabet.txt` можно найти в папке `data`.

### Special thanks to:
- Орфографический фиксер от моей IDE
- Чатгпт за напоминание мне про то, как вообще в c++ делать всякие вещи, типа поиска по массиву
  (потому что систему итераторов придумал Сатана лично)
- Копилот сделал меньше всех работы (actually, не сделал ничего, в c++ файлах он у меня отключен), но почему-то очень хочет себя сюда вписать
- Диме, что заметил для меня, что вообще-то в LLO c > b > a, а не наоборот. А также оказалось, 
что у меня вообще алфавит неправильно парсился.