# TFLcheck
Программа для перебора всех строк, в надежде получить правила для эквивалентной системы переписываний.

### Общий смысл
Берём все строки длины `LENGTH` из алфавита `letters` (то есть перебираются ВООБЩЕ все строки этой длины и из этих букв) и,
далее, для каждой строки применяем правила из `rules.txt`. На каждом этапе применяется только одно правило, однако, если возможно применение нескольких,
они создают дерево возможных трансформаций. Как только redex'ов не осталось, полученная строка считается н.ф. и возвращается вверх.
В итоге из одного слова мы получаем от 1 до N н.ф. (одинаковые при этом удаляются). Если она одна - всё корректно, если нет - применяется алгоритм Кнута-Бендикса
для всех полученных н.ф.

Фундированный порядок - LLO (Армейский) ((Лексикографический)) (((гений))) ((((плейбой...))))

Если хотите улучшить программу - делайте, я в вас верю, вы молодцы, вы справитесь

### Тут настолько много багов, что даже представить трудно, несколько известных мне:

- Минимизации полученных правил нет. Я не знаю как это делать, поэтому такого не реализовано. Следствие - много правил, которые избыточны.
- Всё ещё возможен сценарий нехватки памяти - проблема сама куда-то пропала, и я не знаю куда.
- Медленно. Очень медленно. Очень-очень медленно. (хорошо бы ввести параллельность, но мне в падлу)

### Общие рекомендации

- Не используйте программу.
- При перемещении файла .exe нужно таскать за ним папку data. Если её не будет - ошибки не появится, но также не подгрузятся правила -> программа скажет, что правил вообще не нужно и всё уже в н.ф.
- Наберитесь терпения и, лучше, всё равно периодически проверяйте ветки. Для этого при нахождении разных н.ф. программа выводит цепочку получения. НЕ ПОЛЕНИТЕСЬ ПРОВЕРЯТЬ ХОТЯ БЫ ИНОГДА.
- Если вы нашли ошибку, пожалуйста, сообщите мне (я не знаю, как её исправить, но буду рад узнать о ней). ((ЭТОТ ПУНКТ МНЕ ПРЕДЛОЖИЛ КОПИЛОТ И ОН СЛИШКОМ ХОРОШ, ЧТОБЫ ЕГО НЕ ВСТАВИТЬ))
- Молиться никогда не вредно.
- Программа не умеет в минимизацию. Учитывайте то, что результат будет вообще не минимальным.

### Про формат ввода

- В файле rules.txt правила записываются в формате: `исходная_строка -> конечная_строка`, например, `ab -> a`, `ba -> a`, `aa -> ` (если правило трансформирует в пустую строку, писать эпсилон не надо, но поставить пробел после стрелочки стоит)
- При вопросе о добавлении правил, можно ввести `slow`, `fast`, `skip`, о них чуть дальше
- Первая строка в `alphabet.txt` отвечает за длину строки. Чем длиннее - тем дольше и нестабильнее программа. Воо


### О режиме работы

При выполнении первой итерации, программа покажет, какие правила она считает нужными для добавления. Далее есть 3 варианта

`skip` - пропуск, то есть изначальная система правил никак изменена не будет и вы, например, можете сами выбрать какое правило внести и добавить его вручную.


`fast` - все правила будут добавлены каскадом. То есть перепроверок проводиться не будет и, есть вероятность, что при таком выборе появится много избыточных правил.


`slow` - добавляет правила по одному и перепроверяет систему. Так есть возможность избежать добавления части лишних правил. Рекомендованный способ запуска.

### Special thanks to:
- Орфографический фиксер от моей IDE
- Чатгпт за напоминание мне про то, как вообще в c++ делать всякие вещи, типа поиска по массиву
  (потому что систему итераторов придумал Сатана лично)
- Копилот сделал меньше всех работы, но почему-то очень хочет себя сюда вписать
- Диме, что заметил для меня, что вообще-то в LLO c > b > a, а не наоборот. А также оказалось, 
что у меня вообще алфавит неправильно парсился.